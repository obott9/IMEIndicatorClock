# IMEIndicatorClock Windows移植 判断資料

macOS版IMEIndicatorClockをWindowsへ移植するための比較・判断資料

---

## 1. OS・IMEの違い

### IMEシステムの根本的な違い

| 項目 | macOS | Windows |
|------|-------|---------|
| IME管理 | システム統合型 | アプリケーション連携型 |
| 入力ソース | グローバル（システム全体） | ウィンドウ/スレッド単位 |
| 状態通知 | システム通知で確実に取得 | アクティブウィンドウ依存 |
| API | Carbon TIS (単一API) | IMM32 / TSF (複数API混在) |

### Windows IME検出の現実

```
macOS: 「今、日本語入力がONです」→ 常に正確に取得可能

Windows: 「フォアグラウンドウィンドウのIME状態」→ ウィンドウごとに異なる
         ├─ メモ帳: 日本語ON
         ├─ Chrome: 英語
         └─ VSCode: 日本語OFF
```

**結論**: Windowsでは「システム全体のIME状態」という概念がない

---

## 2. 不可能なこと・制限事項

### 完全に不可能

| 機能 | 理由 |
|------|------|
| システム全体のIME状態表示 | Windowsはウィンドウ単位でIME管理 |
| バックグラウンドウィンドウのIME状態取得 | フォアグラウンドのみ取得可能 |
| 一部サードパーティIMEの状態取得 | API非対応のIMEが存在 |

### 困難・制限あり

| 機能 | 制限内容 | 回避策 |
|------|----------|--------|
| IME ON/OFF検出 | 一部アプリで取得不可（UWP等） | 対応アプリのみサポート |
| マウスカーソル追従 | 高頻度更新でCPU負荷 | 更新間隔の調整 |
| 透過クリックスルー | 実装が複雑 | WS_EX_TRANSPARENT使用 |
| 全画面ゲーム上の表示 | DirectX排他モードで非表示 | ボーダーレスウィンドウのみ対応 |

### macOSと同等に可能

| 機能 | 備考 |
|------|------|
| フローティングウィンドウ表示 | WPF/WinFormsで実装可能 |
| システムトレイアイコン | NotifyIcon使用 |
| 時計表示（アナログ/デジタル） | 完全実装可能 |
| 設定画面 | 完全実装可能 |
| マルチディスプレイ対応 | Screen API使用 |
| ドラッグ移動 | 完全実装可能 |
| 起動時自動実行 | レジストリ/スタートアップフォルダ |

---

## 3. 開発環境の比較

### Windows下 vs WSL下

| 項目 | Windows下開発 | WSL下開発 |
|------|---------------|-----------|
| **Windows APIアクセス** | ★★★★★ 直接アクセス | ✗ 不可能 |
| **IME API使用** | ★★★★★ 可能 | ✗ 不可能 |
| **GUIアプリ作成** | ★★★★★ ネイティブ | △ X11転送必要 |
| **デバッグ** | ★★★★★ 完全対応 | ★★☆☆☆ 制限あり |
| **ビルド速度** | ★★★★☆ 高速 | ★★★☆☆ やや遅い |
| **配布用EXE作成** | ★★★★★ 直接生成 | ✗ クロスコンパイル必要 |

### 結論: WSLでは開発不可

```
IMEIndicatorClockは Windows API (IMM32/TSF) を使用してIME状態を取得する
                    ↓
WSLはLinux環境のため Windows API にアクセスできない
                    ↓
∴ WSL下での開発・実行は不可能
```

**開発は必ずWindows環境で行う必要がある**

---

### Visual Studio vs VSCode

| 項目 | Visual Studio 2022 | VSCode |
|------|-------------------|--------|
| **WPF/WinForms対応** | ★★★★★ デザイナー付き | ★★☆☆☆ コードのみ |
| **C#開発** | ★★★★★ 最適 | ★★★★☆ 拡張機能必要 |
| **C++/WinAPI開発** | ★★★★★ 最適 | ★★★☆☆ 設定が複雑 |
| **デバッグ** | ★★★★★ 高機能 | ★★★☆☆ 基本的 |
| **IntelliSense** | ★★★★★ 完璧 | ★★★★☆ 良好 |
| **起動速度** | ★★☆☆☆ 重い | ★★★★★ 軽い |
| **メモリ使用量** | ★★☆☆☆ 多い | ★★★★★ 少ない |
| **価格** | 無料 (Community) | 無料 |
| **XAMLプレビュー** | ★★★★★ リアルタイム | ✗ なし |

### 推奨

| 言語/FW | 推奨IDE |
|---------|---------|
| C# + WPF | **Visual Studio 2022** (デザイナー必須) |
| C# + WinForms | **Visual Studio 2022** |
| C++ + WinAPI | **Visual Studio 2022** |
| C++ + Qt | VSCode または Qt Creator |

---

## 4. 言語・フレームワーク比較

### 総合比較表

| 言語/FW | 開発効率 | 実行速度 | IME API | UI品質 | 学習コスト | 推奨度 |
|---------|----------|----------|---------|--------|------------|--------|
| **C# + WPF** | ★★★★★ | ★★★★☆ | ★★★★☆ | ★★★★★ | ★★★★☆ | **◎** |
| C# + WinUI 3 | ★★★★☆ | ★★★★☆ | ★★★★☆ | ★★★★★ | ★★★☆☆ | ○ |
| C# + WinForms | ★★★★☆ | ★★★★☆ | ★★★★☆ | ★★★☆☆ | ★★★★★ | ○ |
| C++ + WinAPI | ★★☆☆☆ | ★★★★★ | ★★★★★ | ★★★☆☆ | ★★☆☆☆ | △ |
| C++ + Qt | ★★★★☆ | ★★★★★ | ★★★☆☆ | ★★★★☆ | ★★★☆☆ | ○ |
| Rust + egui | ★★★☆☆ | ★★★★★ | ★★☆☆☆ | ★★★☆☆ | ★★☆☆☆ | △ |
| Electron | ★★★★★ | ★★☆☆☆ | ★☆☆☆☆ | ★★★★☆ | ★★★★☆ | ✗ |

### 各選択肢の詳細

---

#### 【推奨】C# + WPF (.NET 8)

```
メリット:
├─ macOS版(SwiftUI)に最も近いアーキテクチャ
├─ XAML による宣言的UI
├─ 透過ウィンドウが容易
├─ P/Invokeで Windows API 呼び出し可能
├─ 豊富なドキュメント・コミュニティ
└─ Visual Studio のデザイナーサポート

デメリット:
├─ .NET ランタイム必要（自己完結型配布で回避可）
└─ 起動がC++より若干遅い

IME API アクセス: P/Invoke経由で IMM32/TSF 使用可能
```

**開発環境**: Visual Studio 2022 Community（無料）

---

#### C# + WinUI 3

```
メリット:
├─ 最新のWindows UI技術
├─ Fluent Design対応
└─ 将来性が高い

デメリット:
├─ Windows 10 1809以降のみ
├─ 透過ウィンドウの実装が複雑
├─ ドキュメントがWPFより少ない
└─ 一部機能が未成熟
```

---

#### C# + WinForms

```
メリット:
├─ 非常にシンプル
├─ 学習コストが低い
└─ 軽量

デメリット:
├─ UIデザインの自由度が低い
├─ 透過・グラデーションが面倒
└─ 見た目が古くなりがち
```

---

#### C++ + WinAPI (+ Direct2D)

```
メリット:
├─ 最高のパフォーマンス
├─ 依存関係なし（単体EXE）
├─ 完全なシステムアクセス
└─ 最小のファイルサイズ

デメリット:
├─ 開発工数が非常に大きい（3-5倍）
├─ メモリ管理が手動
├─ UI実装が複雑
└─ バグが入りやすい
```

---

#### C++ + Qt

```
メリット:
├─ クロスプラットフォーム可能
├─ 高品質なUI
└─ 豊富なウィジェット

デメリット:
├─ ライセンス注意（LGPLまたは商用）
├─ 配布サイズが大きい
└─ Windows APIは別途呼び出し必要
```

---

## 5. 判断フローチャート

```
開発環境の選択
│
├─ WSLで開発したい → ✗ 不可能（Windows APIが必要）
│
└─ Windows上で開発
    │
    ├─ 単体EXE・最高速度が必須 → C++ + WinAPI
    │                            (開発工数: 大)
    │
    ├─ クロスプラットフォーム必要 → C++ + Qt
    │
    └─ Windows専用でOK
        │
        ├─ 最新UIが必要 + Win10 1809以降限定OK → WinUI 3
        │
        ├─ シンプルさ重視 → WinForms
        │
        └─ バランス重視（推奨）→ WPF ★
```

---

## 6. 推奨構成

### 最終推奨

| 項目 | 選択 |
|------|------|
| **開発環境** | Windows 11 (WSL不可) |
| **IDE** | Visual Studio 2022 Community |
| **言語** | C# 12 |
| **フレームワーク** | .NET 8.0 + WPF |
| **パターン** | MVVM |

### 理由

1. **macOS版との類似性**: SwiftUI ↔ WPF (XAML) は構造が近い
2. **開発効率**: C#は生産性が高く、WPFは成熟している
3. **IME対応**: P/Invokeで完全なAPI アクセス可能
4. **UI品質**: 透過・グラデーション・アニメーションが容易
5. **コスト**: 無料で商用利用可能

---

## 7. 開発開始に必要なもの

### 必須

| 項目 | 入手先 |
|------|--------|
| Windows 10/11 PC | - |
| Visual Studio 2022 Community | https://visualstudio.microsoft.com/ja/ |
| .NET 8.0 SDK | VS2022インストール時に含む |

### Visual Studio インストール時のワークロード

```
☑ .NET デスクトップ開発
  └─ WPF、WinForms、.NET 8.0 が含まれる
```

### 推奨NuGetパッケージ

| パッケージ | 用途 |
|------------|------|
| CommunityToolkit.Mvvm | MVVMパターン実装 |
| Hardcodet.NotifyIcon.Wpf | システムトレイ |
| Newtonsoft.Json | 設定ファイル |

---

## 8. まとめ

### 可能/不可能の整理

| 機能 | 可否 | 備考 |
|------|------|------|
| IMEインジケーター表示 | ◎ | フォアグラウンドウィンドウのみ |
| デスクトップ時計 | ◎ | 完全実装可能 |
| マウスカーソル追従 | ○ | CPU負荷に注意 |
| システム全体のIME状態 | ✗ | Windowsの仕様上不可能 |
| WSLでの開発 | ✗ | Windows APIが必要 |
| VSCodeでの開発 | △ | 可能だがVS推奨 |

### 開発環境の結論

```
┌─────────────────────────────────────────┐
│  Windows上 + Visual Studio 2022        │
│  + C# + WPF (.NET 8.0)                 │
│                                         │
│  これが最も現実的で効率的な選択        │
└─────────────────────────────────────────┘
```
